# -*- coding: utf-8 -*-
"""otimizacao_pmsm_tcc.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qk9NxihDB_8TFoDD4fnnifY-72H8I4wf

# Algoritmo Genético
"""

!pip install scikit-opt

"""# Algoritmo Genético

"""

import numpy as np
from sko.GA import GA
import matplotlib.pyplot as plt

# Parâmetros fixos
P = 500e3  # Potência em Watts
num_fases = 3
num_voltas = 3
num_circuitos_paralelos = 10
num_polos = 34
num_bobinas_serie_fase = 51
R_int = 128.3e-3
R_ext = 159.13e-3
L = 241.4e-3
entreferro_min = 1.4e-3
kfill = 0.7
kd = 0.77
kp = 0.98
kw = kd * kp
velocidade = 3000 #rpm

# Limites das variáveis
limites_variaveis = [
    (131e-3, 136e-3),  # Ri
    (142e-3, 148e-3),  # Rm
    (150e-3, 157e-3),  # Rs
    (3.33, 11.67),     # A (kA/m) - Limites baseados na relação AJ
    (90, 270), (90, 270), (90, 270),
    (90, 270), (90, 270), (90, 270),
]

def calcular_massa_ativa(variaveis):
    Ri, Rm, Rs, A_var, *_ = variaveis
    rho_ferro = 7870
    rho_cobre = 8960
    rho_ima = 7500

    Vol_estator = np.pi * L * (R_ext**2 - Rs**2)
    Vol_rotor = np.pi * L * (Ri**2 - R_int**2)
    Vol_ima = np.pi * L * (Rm**2 - Ri**2)
    Vol_cobre = np.pi * L * (Rs**2 - Rm**2) * kfill
    Re = (Rm + Rs + entreferro_min) / 2
    Vol_EW = (3 * np.pi**5 * Re**3 * kfill) / (4 * num_bobinas_serie_fase**2)

    M_nucleo = rho_ferro * (Vol_estator + Vol_rotor)
    M_cobre = rho_cobre * (Vol_cobre + Vol_EW)
    M_ima = rho_ima * Vol_ima

    return M_nucleo + M_cobre + M_ima

def fitness_func(variaveis):
    Ri, Rm, Rs, A_var, theta1, theta2, theta3, theta4, theta5, theta6 = variaveis  # Unpacking all variables
    massa_ativa = calcular_massa_ativa(variaveis)

    # Cálculo do entreferro e Rg
    Rg = Rm + entreferro_min

    # Convertendo ângulos para radianos para cálculos de distribuição espacial
    angles_rad = np.array([theta1, theta2, theta3, theta4, theta5, theta6]) * np.pi / 180

    # Penalidades para orientação dos ímãs do arranjo Halbach
    # 1. Verifica a progressão ideal de 90° entre ímãs adjacentes
    ideal_progression = np.pi/2  # 90 graus em radianos
    angle_differences = np.diff(angles_rad)
    progression_error = np.abs(angle_differences - ideal_progression)
    penalidade_halbach = np.mean(progression_error)**2 * 1e4

    # 2. Verifica se a sequência completa cobre aproximadamente 360° (2π)
    total_rotation = np.max(angles_rad) - np.min(angles_rad)
    if total_rotation < 2*np.pi:  # Deve cobrir 360 graus
        penalidade_cobertura = ((2*np.pi - total_rotation)/(2*np.pi))**2 * 1e4
    else:
        penalidade_cobertura = 0

    # i_RMS usando A variável
    i_RMS = 2 * np.pi * Rg * A_var * 1000  # Convertendo A de kA/m para A/m

    # Torque (usando kw original)
    B_gap = 1 - (R_int / R_ext) ** (2 * num_polos/2)
    torque = (kw * A_var * 1000 * (B_gap/np.sqrt(2)) * np.pi * L * (Ri**2 - R_int**2))*1000
    erro_torque_rel = (torque - 1600) / 1600
    penalidade_torque = (erro_torque_rel)**2 * 1e4

    # Força Contra Eletromotriz
    FCEM = (2 * L * (B_gap/np.sqrt(2))) * ((Rs + Rm)/2) * num_voltas* kd * (17*(2*np.pi*velocidade/60))/10
    erro_FCEM_rel = abs(FCEM - 300) / 300
    penalidade_FCEM = (erro_FCEM_rel)**2 * 1e4

    # Densidade de corrente J
    area_mm2 = np.pi * (Rs**2 - Rg**2) * kfill * 1e6
    J = (2 * i_RMS * num_voltas * num_fases * num_bobinas_serie_fase) / (area_mm2*num_circuitos_paralelos)
    excesso_J = max(0, J - 30) / 30
    penalidade_J = (excesso_J)**2 * 1e4

    # B_gap
    excesso_B_sup = max(0, B_gap - 1.05)
    excesso_B_inf = max(0, 0.8 - B_gap)
    penalidade_Bgap = (excesso_B_sup**2 + excesso_B_inf**2) * 1e4

    # Verificação do produto A*J
    AJ_produto = (A_var * 1000) * J  # A em A/m * J em A/mm²

    # Verifica se o produto A*J está dentro do intervalo desejado [10e10, 35e10]
    if AJ_produto < 10e10:
        # Penalidade para valores abaixo do mínimo
        penalidade_AJ = ((10e10 - AJ_produto)/10e10)**2 * 1e4
    elif AJ_produto > 35e10:
        # Penalidade para valores acima do máximo
        penalidade_AJ = ((AJ_produto - 35e10)/35e10)**2 * 1e4
    else:
        penalidade_AJ = 0

    # Penalidade total
    penalidade_total = (penalidade_torque + penalidade_J + penalidade_Bgap + penalidade_FCEM +
                       penalidade_halbach + penalidade_cobertura + penalidade_AJ)

    # Fitness final
    fitness = 1.0 / (massa_ativa + penalidade_total + 1e-6)
    return fitness

# Configuração do GA
num_individuos = 50
num_geracoes = 100
dimensoes = len(limites_variaveis)
limites_inferiores = np.array([limite[0] for limite in limites_variaveis])
limites_superiores = np.array([limite[1] for limite in limites_variaveis])

# Lista para armazenar os melhores fitness de cada geração
historico_fitness = []

otimizador = GA(
    func=lambda x: -fitness_func(x),
    n_dim=dimensoes,
    size_pop=num_individuos,
    max_iter=num_geracoes,
    lb=limites_inferiores,
    ub=limites_superiores,
    prob_mut=0.01
)

# Executa o GA e armazena o histórico
for gen in range(num_geracoes):
    otimizador.run(1)  # Executa uma geração
    historico_fitness.append(-otimizador.best_y)  # Armazena o melhor fitness

melhor_solucao = otimizador.best_x
melhor_fitness = -otimizador.best_y

# Plot da evolução do fitness
plt.figure(figsize=(10, 6))
plt.plot(range(1, len(historico_fitness) + 1), historico_fitness, 'b-')
plt.title('Evolução da Função de Aptidão')
plt.xlabel('Número de Iterações')
plt.ylabel('Função de Aptidão (1/kg)')
plt.ticklabel_format(axis='y', style='sci', scilimits=(0,0))  # Formato científico
plt.show()

# Cálculo dos valores ótimos de i_RMS e A
Ri_otimo = melhor_solucao[0]
Rm_otimo = melhor_solucao[1]
Rs_otimo = melhor_solucao[2]
Rg_otimo = Rm_otimo + entreferro_min

# Cálculo do B_gap ótimo
B_gap_otimo = 1 - (R_int / R_ext) ** (2 * num_polos/2)

# Cálculo de A e i_RMS ótimos
A_otimo = melhor_solucao[3]
i_RMS_otimo = 2 * np.pi * Rg_otimo * A_otimo * 1000

# Cálculo do torque ótimo
torque_otimo = (kw * A_otimo *1000* (B_gap_otimo/np.sqrt(2)) * np.pi * L * (Ri_otimo**2 - R_int**2))*1000

# Cálculo da FCEM ótima
Rw_otimo = (Rm_otimo + Rs_otimo)/2
FCEM_otimo = (2 * L * B_gap_otimo * Rw_otimo * num_voltas * 1 * (17*(2*np.pi*velocidade/60)))/10

# Cálculo da densidade de corrente J ótima
area_mm2_otimo = np.pi * (Rs_otimo**2 - Rg_otimo**2) * kfill * 1e6
J_otimo = (2 * i_RMS_otimo * num_voltas * (num_fases * num_bobinas_serie_fase)) / (area_mm2_otimo * num_circuitos_paralelos)

# Resultados reais
massa_real = calcular_massa_ativa(melhor_solucao)
densidade_potencia_real = P / massa_real  # em W/kg

# Impressão dos resultados
print("\n--- Resultados ---")
print("Melhor solução encontrada:", melhor_solucao)
print(f"Massa ativa estimada: {massa_real:.2f} kg")
print(f"Densidade de potência estimada: {densidade_potencia_real:.2f} W/kg")
print(f"Densidade de potência: {densidade_potencia_real/1000:.2f} kW/kg")

print(f"\n--- Valores otimizados ---")
print(f"Dimensões:")
print(f"Ri: {Ri_otimo*1000:.2f} mm")
print(f"Rm: {Rm_otimo*1000:.2f} mm")
print(f"Rs: {Rs_otimo*1000:.2f} mm")
print(f"Rg: {Rg_otimo*1000:.2f} mm")

print(f"\nParâmetros elétricos:")
print(f"i_RMS: {i_RMS_otimo:.2f} A")
print(f"A: {A_otimo:.2f} kA/m (limites baseados na relação AJ: 3.33 <= A <= 11.67)")
print(f"B_gap: {B_gap_otimo:.3f} T")
print(f"Torque: {torque_otimo:.2f} N.m")
print(f"FCEM: {FCEM_otimo:.2f} V")
print(f"J: {J_otimo:.2f} A/mm² (deve ser <= 30)")

print(f"\nCaracterísticas do arranjo Halbach:")
angles = melhor_solucao[4:]
print("Ângulos dos ímãs (graus):", [f"{theta:.2f}" for theta in angles])
angles_rad = np.array(angles) * np.pi / 180
angle_differences = np.diff(angles_rad) * 180 / np.pi
print("Diferenças entre ímãs adjacentes (graus):", [f"{diff:.2f}" for diff in angle_differences])
print(f"Rotação total do arranjo: {(np.max(angles) - np.min(angles)):.2f}°")
print(f"Desvio médio do ideal de 90°: {np.mean(np.abs(angle_differences - 90)):.2f}°")

# Verificação das restrições
print(f"\n--- Verificação das restrições ---")
print(f"Torque erro (%): {((torque_otimo - 1600)/1600)*100:.2f}%")
print(f"FCEM erro (%): {(abs(FCEM_otimo - 300)/300)*100:.2f}%")
print(f"J máximo erro (%): {((J_otimo - 30)/30)*100:.2f}% (deve ser < 2%)")
print(f"B_gap: {B_gap_otimo:.3f} T (deve estar entre 0.8 e 1.05 T)")
print(f"A*J: {((A_otimo*1000)*J_otimo/10e10):.2f}e10 (deve estar entre 10e10 e 35e10)")

"""# Enxame de Partículas"""

!pip install pyswarms

"""# Loop para determinar melhor resultado PSO

"""

import numpy as np
import pyswarms as ps
import matplotlib.pyplot as plt
import time

# Parâmetros fixos
P = 500e3  # Potência em Watts
num_fases = 3
num_voltas = 3
num_circuitos_paralelos = 10
num_polos = 34
num_bobinas_serie_fase = 51
R_int = 128.3e-3
R_ext = 159.13e-3
L = 241.4e-3
entreferro_min = 1.4e-3
kfill = 0.7
kd = 0.77
kp = 0.98
kw = kp*kd
velocidade = 3000 #rpm

# Limites das variáveis
limites_variaveis = [
    (131e-3, 136e-3),  # Ri
    (142e-3, 148e-3),  # Rm
    (150e-3, 157e-3),  # Rs
    (3.33, 11.67),     # A (kA/m) - Limites baseados na relação AJ
    (90, 270), (90, 270), (90, 270),
    (90, 270), (90, 270), (90, 270),
]

def calcular_massa_ativa(variaveis):
    Ri, Rm, Rs, A_var, *_ = variaveis
    rho_ferro = 7870
    rho_cobre = 8960
    rho_ima = 7500

    Vol_estator = np.pi * L * (R_ext**2 - Rs**2)
    Vol_rotor = np.pi * L * (Ri**2 - R_int**2)
    Vol_ima = np.pi * L * (Rm**2 - Ri**2)
    Vol_cobre = np.pi * L * (Rs**2 - Rm**2) * kfill
    Re = (Rm + Rs + entreferro_min) / 2
    Vol_EW = (3 * np.pi**5 * Re**3 * kfill) / (4 * num_bobinas_serie_fase**2)

    M_nucleo = rho_ferro * (Vol_estator + Vol_rotor)
    M_cobre = rho_cobre * (Vol_cobre + Vol_EW)
    M_ima = rho_ima * Vol_ima

    return M_nucleo + M_cobre + M_ima

def fitness_func(X):
    n = X.shape[0]
    fitness = np.zeros(n)

    for i in range(n):
        Ri, Rm, Rs, A_var, theta1, theta2, theta3, theta4, theta5, theta6 = X[i]

        # Verificações básicas de restrições geométricas
        if Rm <= Ri or Rs <= Rm:
            fitness[i] = -1e10
            continue

        massa_ativa = calcular_massa_ativa(X[i])

        # Cálculo do entreferro e Rg
        Rg = Rm + entreferro_min

        # Convertendo ângulos para radianos para cálculos de distribuição espacial
        angles_rad = np.array([theta1, theta2, theta3, theta4, theta5, theta6]) * np.pi / 180

        # Penalidades para orientação dos ímãs do arranjo Halbach
        ideal_progression = np.pi/2
        angle_differences = np.diff(angles_rad)
        progression_error = np.abs(angle_differences - ideal_progression)
        penalidade_halbach = np.mean(progression_error)**2 * 1e4

        total_rotation = np.max(angles_rad) - np.min(angles_rad)
        if total_rotation < 2*np.pi:
            penalidade_cobertura = ((2*np.pi - total_rotation)/(2*np.pi))**2 * 1e4
        else:
            penalidade_cobertura = 0

        # i_RMS usando A variável
        i_RMS = 2 * np.pi * Rg * A_var * 1000

        # Torque com penalidade exponencial mais agressiva
        B_gap = 1 - (R_int / R_ext) ** (2 * num_polos/2)
        torque = (kw * A_var * 1000 * (B_gap/np.sqrt(2)) * np.pi * L * (Ri**2 - R_int**2))*1000
        erro_torque_rel = abs(torque - 1600) / 1600

        # Nova penalidade para torque com três níveis
        if erro_torque_rel > 0.05:  # Erro > 5%
            penalidade_torque = np.exp(erro_torque_rel * 15) * 1e6
        elif erro_torque_rel > 0.02:  # Erro entre 2% e 5%
            penalidade_torque = np.exp(erro_torque_rel * 12) * 1e5
        else:  # Erro <= 2%
            penalidade_torque = (erro_torque_rel)**2 * 1e5

        # Adicional: penalidade assimétrica para torque abaixo do alvo
        if torque < 1600:  # Se estiver abaixo do alvo
            penalidade_torque *= 2.0  # Dobra a penalidade

        # FCEM
        FCEM = (2 * L * (B_gap/np.sqrt(2))) * ((Rs + Rm)/2) * num_voltas * kd * (17*(2*np.pi*velocidade/60))/10
        erro_FCEM_rel = abs(FCEM - 300) / 300
        penalidade_FCEM = (erro_FCEM_rel)**2 * 1e4

        # Densidade de corrente J com penalidade exponencial
        area_mm2 = np.pi * (Rs**2 - Rg**2) * kfill * 1e6
        J = (2 * i_RMS * num_voltas * num_fases * num_bobinas_serie_fase) / (area_mm2*num_circuitos_paralelos)

        # Penalidade exponencial para J
        if J > 30:
            excesso_J = (J - 30) / 30
            penalidade_J = np.exp(excesso_J * 10) * 1e6
        else:
            penalidade_J = 0

        # B_gap
        excesso_B_sup = max(0, B_gap - 1.05)
        excesso_B_inf = max(0, 0.8 - B_gap)
        penalidade_Bgap = (excesso_B_sup**2 + excesso_B_inf**2) * 1e4

        # Verificação do produto A*J
        AJ_produto = (A_var * 1000) * J

        if AJ_produto < 10e10:
            penalidade_AJ = ((10e10 - AJ_produto)/10e10)**2 * 1e4
        elif AJ_produto > 35e10:
            penalidade_AJ = ((AJ_produto - 35e10)/35e10)**2 * 1e4
        else:
            penalidade_AJ = 0

        # Penalidade total com pesos ajustados
        penalidade_total = (penalidade_torque * 15 +   # Aumentado para 15x
                          penalidade_J * 10 +          # Mantido em 10x
                          penalidade_Bgap +
                          penalidade_FCEM +
                          penalidade_halbach +
                          penalidade_cobertura +
                          penalidade_AJ)

        # Fitness final (negativo para minimização)
        fitness[i] = -(1.0 / (massa_ativa + penalidade_total + 1e-6))

    return fitness

# PSO Configurações
dim = len(limites_variaveis)
lim_inf = np.array([x[0] for x in limites_variaveis])
lim_sup = np.array([x[1] for x in limites_variaveis])
opcoes = {
    'c1': 2.0,    # Increased cognitive parameter for better local exploitation
    'c2': 1.0,    # Reduced social parameter to focus more on individual improvement
    'w': 0.8,     # Slightly increased inertia for better exploration
    'k': 30,      # Keep number of neighbors
    'p': 2        # Minkowski p-norm
}

# Lista para armazenar o histórico de fitness
historico_fitness = []
melhor_fitness_global = np.inf
melhor_solucao_global = None

# Execução do PSO por 60 segundos
start_time = time.time()
iteracao = 0

while time.time() - start_time < 600:
    # Inicialização do PSO com topologia local
    otimizador = ps.single.LocalBestPSO(
        n_particles=400,  # Increased further for better exploration
        dimensions=dim,
        options=opcoes,
        bounds=(lim_inf, lim_sup)
    )

    # Executa uma otimização
    custo, pos = otimizador.optimize(fitness_func, iters=200, verbose=False)  # Increased iterations further

    # Atualiza o histórico
    historico_fitness.extend([-f for f in otimizador.cost_history])

    # Atualiza a melhor solução global se necessário
    if custo < melhor_fitness_global:
        melhor_fitness_global = custo
        melhor_solucao_global = pos.copy()

    iteracao += 1
    print(f"Iteração {iteracao} completa. Melhor fitness: {-melhor_fitness_global:.2e}")

# Converte para os valores positivos finais
melhor_solucao = melhor_solucao_global
melhor_fitness = -melhor_fitness_global

print(f"\nOtimização concluída após {iteracao} iterações em {time.time() - start_time:.1f} segundos")

# Resultados finais
massa_final = calcular_massa_ativa(melhor_solucao)
densidade_pot = P / massa_final

# Cálculo dos valores ótimos
Ri_otimo = melhor_solucao[0]
Rm_otimo = melhor_solucao[1]
Rs_otimo = melhor_solucao[2]
A_otimo = melhor_solucao[3]
Rg_otimo = Rm_otimo + entreferro_min

# Cálculo do B_gap ótimo
B_gap_otimo = 1 - (R_int / R_ext) ** (2 * num_polos/2)

# Cálculo de A e i_RMS ótimos
i_RMS_otimo = 2 * np.pi * Rg_otimo * A_otimo * 1000

# Cálculo do torque ótimo
torque_otimo = (kw * A_otimo * 1000 * (B_gap_otimo/np.sqrt(2)) * np.pi * L * (Ri_otimo**2 - R_int**2))*1000

# Cálculo da FCEM ótima
FCEM_otimo = (2 * L * (B_gap_otimo/np.sqrt(2))) * ((Rs_otimo + Rm_otimo)/2) * num_voltas * kd * (17*(2*np.pi*velocidade/60))/10

# Cálculo da densidade de corrente J ótima
area_mm2_otimo = np.pi * (Rs_otimo**2 - Rg_otimo**2) * kfill * 1e6
J_otimo = (2 * i_RMS_otimo * num_voltas * (num_fases * num_bobinas_serie_fase)) / (area_mm2_otimo * num_circuitos_paralelos)

# Resultados reais
massa_real = calcular_massa_ativa(melhor_solucao)
densidade_potencia_real = P / massa_real  # em W/kg

# Plot da evolução do fitness
plt.figure(figsize=(10, 6))
plt.plot(range(1, len(historico_fitness) + 1), historico_fitness, 'b-')
plt.title('Evolução da Função de Aptidão')
plt.xlabel('Número de Iterações')
plt.ylabel('Função de Aptidão (1/kg)')
plt.ticklabel_format(axis='y', style='sci', scilimits=(0,0))  # Formato científico
plt.show()

# Impressão dos resultados
print("\n--- Resultados ---")
print("Melhor solução encontrada:", melhor_solucao)
print(f"Massa ativa estimada: {massa_real:.2f} kg")
print(f"Densidade de potência estimada: {densidade_potencia_real:.2f} W/kg")
print(f"Densidade de potência: {densidade_potencia_real/1000:.2f} kW/kg")

print(f"\n--- Valores otimizados ---")
print(f"Dimensões:")
print(f"Ri: {Ri_otimo*1000:.2f} mm")
print(f"Rm: {Rm_otimo*1000:.2f} mm")
print(f"Rs: {Rs_otimo*1000:.2f} mm")
print(f"Rg: {Rg_otimo*1000:.2f} mm")

print(f"\nParâmetros elétricos:")
print(f"i_RMS: {i_RMS_otimo:.2f} A")
print(f"A: {A_otimo:.2f} kA/m (limites baseados na relação AJ: 3.33 <= A <= 11.67)")
print(f"B_gap: {B_gap_otimo:.3f} T")
print(f"Torque: {torque_otimo:.2f} N.m")
print(f"FCEM: {FCEM_otimo:.2f} V")
print(f"J: {J_otimo:.2f} A/mm² (deve ser <= 30)")

print(f"\nCaracterísticas do arranjo Halbach:")
angles = melhor_solucao[4:]
print("Ângulos dos ímãs (graus):", [f"{theta:.2f}" for theta in angles])
angles_rad = np.array(angles) * np.pi / 180
angle_differences = np.diff(angles_rad) * 180 / np.pi
print("Diferenças entre ímãs adjacentes (graus):", [f"{diff:.2f}" for diff in angle_differences])
print(f"Rotação total do arranjo: {(np.max(angles) - np.min(angles)):.2f}°")
print(f"Desvio médio do ideal de 90°: {np.mean(np.abs(angle_differences - 90)):.2f}°")

print(f"\n--- Verificação das restrições ---")
print(f"Torque erro (%): {((torque_otimo - 1600)/1600)*100:.2f}%")
print(f"FCEM erro (%): {(abs(FCEM_otimo - 300)/300)*100:.2f}%")
print(f"J máximo erro (%): {((J_otimo - 30)/30)*100:.2f}% (deve ser < 2%)")
print(f"B_gap: {B_gap_otimo:.3f} T (deve estar entre 0.8 e 1.05 T)")
print(f"A*J: {((A_otimo*1000)*J_otimo/10e10):.2f}e10 (deve estar entre 10e10 e 35e10)")

"""# Colônia Artificial de Abelhas

"""

import numpy as np
import matplotlib.pyplot as plt

# Parâmetros fixos
P = 500e3  # Potência em Watts
num_fases = 3
num_voltas = 3
num_circuitos_paralelos = 10
num_polos = 34
num_bobinas_serie_fase = 51
R_int = 128.3e-3
R_ext = 159.13e-3
L = 241.4e-3
entreferro_min = 1.4e-3
kfill = 0.7
kd = 0.77
kp = 0.98
kw = kp*kd
velocidade = 3000 #rpm

# Limites das variáveis
limites_variaveis = [
    (131e-3, 136e-3),  # Ri
    (142e-3, 148e-3),  # Rm
    (150e-3, 157e-3),  # Rs
    (3.33, 11.67),     # A (kA/m) - Limites baseados na relação AJ
    (90, 270), (90, 270), (90, 270),
    (90, 270), (90, 270), (90, 270),
]

def calcular_massa_ativa(variaveis):
    Ri, Rm, Rs, A_var, *_ = variaveis
    rho_ferro = 7870
    rho_cobre = 8960
    rho_ima = 7500

    Vol_estator = np.pi * L * (R_ext**2 - Rs**2)
    Vol_rotor = np.pi * L * (Ri**2 - R_int**2)
    Vol_ima = np.pi * L * (Rm**2 - Ri**2)
    Vol_cobre = np.pi * L * (Rs**2 - Rm**2) * kfill
    Re = (Rm + Rs + entreferro_min) / 2
    Vol_EW = (3 * np.pi**5 * Re**3 * kfill) / (4 * num_bobinas_serie_fase**2)

    M_nucleo = rho_ferro * (Vol_estator + Vol_rotor)
    M_cobre = rho_cobre * (Vol_cobre + Vol_EW)
    M_ima = rho_ima * Vol_ima

    return M_nucleo + M_cobre + M_ima

def fitness_func(variaveis):
    Ri, Rm, Rs, A_var, theta1, theta2, theta3, theta4, theta5, theta6 = variaveis  # Unpacking all variables
    massa_ativa = calcular_massa_ativa(variaveis)

    # Cálculo do entreferro e Rg
    Rg = Rm + entreferro_min

    # Convertendo ângulos para radianos para cálculos de distribuição espacial
    angles_rad = np.array([theta1, theta2, theta3, theta4, theta5, theta6]) * np.pi / 180

    # Penalidades para orientação dos ímãs do arranjo Halbach
    # 1. Verifica a progressão ideal de 90° entre ímãs adjacentes
    ideal_progression = np.pi/2  # 90 graus em radianos
    angle_differences = np.diff(angles_rad)
    progression_error = np.abs(angle_differences - ideal_progression)
    penalidade_halbach = np.mean(progression_error)**2 * 1e4

    # 2. Verifica se a sequência completa cobre aproximadamente 360° (2π)
    total_rotation = np.max(angles_rad) - np.min(angles_rad)
    if total_rotation < 2*np.pi:  # Deve cobrir 360 graus
        penalidade_cobertura = ((2*np.pi - total_rotation)/(2*np.pi))**2 * 1e4
    else:
        penalidade_cobertura = 0

    # i_RMS usando A variável
    i_RMS = 2 * np.pi * Rg * A_var * 1000  # Convertendo A de kA/m para A/m

    # Torque
    B_gap = 1 - (R_int / R_ext) ** (2 * num_polos/2)
    torque = (kw * A_var * 1000 * (B_gap/np.sqrt(2)) * np.pi * L * (Ri**2 - R_int**2))*1000
    erro_torque_rel = (torque - 1600) / 1600
    penalidade_torque = (erro_torque_rel)**2 * 1e4

    # Força Contra Eletromotriz
    FCEM = (2 * L * (B_gap/np.sqrt(2))) * ((Rs + Rm)/2) * num_voltas* kd * (17*(2*np.pi*velocidade/60))/10
    erro_FCEM_rel = abs(FCEM - 300) / 300
    penalidade_FCEM = (erro_FCEM_rel)**2 * 1e4

    # Densidade de corrente J
    area_mm2 = np.pi * (Rs**2 - Rg**2) * kfill * 1e6
    J = (2 * i_RMS * num_voltas * num_fases * num_bobinas_serie_fase) / (area_mm2*num_circuitos_paralelos)
    excesso_J = max(0, J - 30) / 30
    penalidade_J = (excesso_J)**2 * 1e4

    # B_gap
    excesso_B_sup = max(0, B_gap - 1.05)
    excesso_B_inf = max(0, 0.8 - B_gap)
    penalidade_Bgap = (excesso_B_sup**2 + excesso_B_inf**2) * 1e4

    # Verificação do produto A*J
    AJ_produto = (A_var * 1000) * J  # A em A/m * J em A/mm²

    # Verifica se o produto A*J está dentro do intervalo desejado [10e10, 35e10]
    if AJ_produto < 10e10:
        # Penalidade para valores abaixo do mínimo
        penalidade_AJ = ((10e10 - AJ_produto)/10e10)**2 * 1e4
    elif AJ_produto > 35e10:
        # Penalidade para valores acima do máximo
        penalidade_AJ = ((AJ_produto - 35e10)/35e10)**2 * 1e4
    else:
        penalidade_AJ = 0

    # Penalidade total
    penalidade_total = (penalidade_torque + penalidade_J + penalidade_Bgap + penalidade_FCEM +
                       penalidade_halbach + penalidade_cobertura + penalidade_AJ)

    # Fitness final
    fitness = 1.0 / (massa_ativa + penalidade_total + 1e-6)
    return fitness

# Algoritmo de Colônia de Abelhas (ABC)
def abc_algorithm(fitness_func, limites, num_abelhas=50, num_iteracoes=100, limite_tentativas=10):
    num_variaveis = len(limites)
    limites_inferiores = np.array([lim[0] for lim in limites])
    limites_superiores = np.array([lim[1] for lim in limites])

    populacao = limites_inferiores + (limites_superiores - limites_inferiores) * np.random.rand(num_abelhas, num_variaveis)
    fitness = np.array([fitness_func(ind) for ind in populacao])
    tentativas = np.zeros(num_abelhas)

    melhor_solucao = populacao[np.argmax(fitness)]
    melhor_fitness = np.max(fitness)
    fitness_history = [melhor_fitness]

    for _ in range(num_iteracoes):
        # Operárias
        for i in range(num_abelhas):
            k = np.random.randint(num_abelhas)
            while k == i:
                k = np.random.randint(num_abelhas)
            phi = np.random.uniform(-1, 1, num_variaveis)
            nova = populacao[i] + phi * (populacao[i] - populacao[k])
            nova = np.clip(nova, limites_inferiores, limites_superiores)
            nova_fitness = fitness_func(nova)
            if nova_fitness > fitness[i]:
                populacao[i] = nova
                fitness[i] = nova_fitness
                tentativas[i] = 0
            else:
                tentativas[i] += 1

        # Espectadoras
        prob = fitness / np.sum(fitness)
        for i in range(num_abelhas):
            if np.random.rand() < prob[i]:
                k = np.random.randint(num_abelhas)
                while k == i:
                    k = np.random.randint(num_abelhas)
                phi = np.random.uniform(-1, 1, num_variaveis)
                nova = populacao[i] + phi * (populacao[i] - populacao[k])
                nova = np.clip(nova, limites_inferiores, limites_superiores)
                nova_fitness = fitness_func(nova)
                if nova_fitness > fitness[i]:
                    populacao[i] = nova
                    fitness[i] = nova_fitness
                    tentativas[i] = 0
                else:
                    tentativas[i] += 1

        # Exploradoras
        for i in range(num_abelhas):
            if tentativas[i] > limite_tentativas:
                populacao[i] = limites_inferiores + (limites_superiores - limites_inferiores) * np.random.rand(num_variaveis)
                fitness[i] = fitness_func(populacao[i])
                tentativas[i] = 0

        if np.max(fitness) > melhor_fitness:
            melhor_solucao = populacao[np.argmax(fitness)]
            melhor_fitness = np.max(fitness)

        fitness_history.append(melhor_fitness)

    return melhor_solucao, melhor_fitness, fitness_history

# Executa o ABC
melhor_solucao, melhor_fitness, fitness_history = abc_algorithm(fitness_func, limites_variaveis)

# Massa e densidade real
massa_real = calcular_massa_ativa(melhor_solucao)
densidade_pot_real = P / massa_real  # em W/kg

# Cálculos adicionais para os resultados
Ri_otimo, Rm_otimo, Rs_otimo, A_otimo, *angles = melhor_solucao
Rg_otimo = Rm_otimo + entreferro_min
B_gap_otimo = 1 - (R_int / R_ext) ** (2 * num_polos/2)
i_RMS_otimo = 2 * np.pi * Rg_otimo * A_otimo * 1000
area_mm2_otimo = np.pi * (Rs_otimo**2 - Rg_otimo**2) * kfill * 1e6
J_otimo = (2 * i_RMS_otimo * num_voltas * num_fases * num_bobinas_serie_fase) / (area_mm2_otimo * num_circuitos_paralelos)
torque_otimo = (kw * A_otimo * 1000 * (B_gap_otimo/np.sqrt(2)) * np.pi * L * (Ri_otimo**2 - R_int**2))*1000
FCEM_otimo = (2 * L * (B_gap_otimo/np.sqrt(2))) * ((Rs_otimo + Rm_otimo)/2) * num_voltas * kd * (17*(2*np.pi*velocidade/60))/10

# Resultados
print("\n--- RESULTADOS ---")
print("Melhor solução encontrada:", melhor_solucao)
print(f"Fitness (1/kg): {melhor_fitness:.6f}")
print(f"Massa ativa estimada: {massa_real:.2f} kg")
print(f"Densidade de potência estimada: {densidade_pot_real:.2f} W/kg")
print(f"Densidade de potência: {densidade_pot_real/1000:.2f} kW/kg")

print(f"\n--- Valores otimizados ---")
print(f"Dimensões:")
print(f"Ri: {Ri_otimo*1000:.2f} mm")
print(f"Rm: {Rm_otimo*1000:.2f} mm")
print(f"Rs: {Rs_otimo*1000:.2f} mm")
print(f"Rg: {Rg_otimo*1000:.2f} mm")

print(f"\nParâmetros elétricos:")
print(f"i_RMS: {i_RMS_otimo:.2f} A")
print(f"A: {A_otimo:.2f} kA/m (limites baseados na relação AJ: 3.33 <= A <= 11.67)")
print(f"B_gap: {B_gap_otimo:.3f} T")
print(f"Torque: {torque_otimo:.2f} N.m")
print(f"FCEM: {FCEM_otimo:.2f} V")
print(f"J: {J_otimo:.2f} A/mm² (deve ser <= 30)")

print(f"\nCaracterísticas do arranjo Halbach:")
angles = melhor_solucao[4:]
print("Ângulos dos ímãs (graus):", [f"{theta:.2f}" for theta in angles])
angles_rad = np.array(angles) * np.pi / 180
angle_differences = np.diff(angles_rad) * 180 / np.pi
print("Diferenças entre ímãs adjacentes (graus):", [f"{diff:.2f}" for diff in angle_differences])
print(f"Rotação total do arranjo: {(np.max(angles) - np.min(angles)):.2f}°")
print(f"Desvio médio do ideal de 90°: {np.mean(np.abs(angle_differences - 90)):.2f}°")

print(f"\n--- Verificação das restrições ---")
print(f"Torque erro (%): {((torque_otimo - 1600)/1600)*100:.2f}%")
print(f"FCEM erro (%): {(abs(FCEM_otimo - 300)/300)*100:.2f}%")
print(f"J máximo erro (%): {((J_otimo - 30)/30)*100:.2f}% (deve ser < 2%)")
print(f"B_gap: {B_gap_otimo:.3f} T (deve estar entre 0.8 e 1.05 T)")
print(f"A*J: {((A_otimo*1000)*J_otimo/10e10):.2f}e10 (deve estar entre 10e10 e 35e10)")

# Gráfico
plt.figure(figsize=(10, 6))
plt.plot(fitness_history, 'b-')
plt.xlabel("Iteração")
plt.ylabel("Aptidão (1/kg)")
plt.title("Evolução da Aptidão")
plt.show()

import numpy as np

2*0.6*32.67*0.0035